#+ -*-org-*-; Time-stamp: <2013-01-01 16:45:43 leo>

              ROADMAP IMPLEMENTATION



* Introduction
  When programming or writing LaTeX report (or anything else involving
  editing text files), I use a "roadmap", a file containing useful
  information about what's left to do, ideas, etc.

  Believe it or not, it relies on org-mode. The functions here allow
  to update this file automatically from small tags written directly
  in the code I am writing (no need to move back to the roadmap and
  then back again to what I'm working on).

  The basic concept is that of _item_. An item is just a case
  sensitive word not containing any space enclosed between exclamation
  marks anywhere in a file. Thus, it should be particular (ex: 'the'
  is a bad item while 'TODO' is a good one). Current items are:
    - TODO These correspond to tasks left to be done.
    - IDEA Possible improvement or directions to explore.

** Usage of the script
  The roadmap script is used as follows:
    + roadmap -n
      Creates a new roadmap at the given point.
    + roadmap -u
      Updates the roadmap in the current directory.
    + roadmap -h
      Prints the path to the roadmap of which the current file depends
      on.

** Minor-mode
  A minor-mode for roadmap is provided to use it easily with emacs. It
  gives functions allowing to:
    + Easily insert items.
    + Fontify them
    + Update a roadmap.
    + Go to the roadmap of which a files depends.
    + !IDEA! Add links to compile the project
    + !IDEA! Add a list of all the commits' short description.
      For instance, we could use "grep -v "[^ ]:" <(git log)" or
      something.

* Description
** Description of the roadmap itself
   A roadmap is made of the following parts.
*** Statistics
    + The number of files in the directory (sorted by extension) and
      their length (and total length).
    + !TODO! Date of the commits and description (if any).
*** Lists
    Lists of the different items considered. Each line is as follows:

    "** ITEM description"

    where "description" is a link to the file and line where the item
    was as well as the string following the item in the file.

    Currently supported lists are:
    + TODO list
    + IDEA list

    These part should not be modified by hand: it is this programs
    task to generate them. Any modification is thus overriden during
    the next update.
*** Structure
    !TODO! implement the treeview structure of the folder.
    A simple treeview of the folder structure of the directory where
    each node is a link to what it corresponds to. If two files have
    identical names (ex: class.hpp, class.cpp or report.tex and
    report.pdf) then a unique link will open both at the same time.

** Description of the programs used
   From a technical point of view, the implementation has several
   different aspects. Indeed, while bash functions are used to create
   the file, emacs'org-mode is used to read it and roadmap-mode is
   used to interact with it from other buffers.
   
*** Bash functions
    The aim of the bash functions is to create the file itself by
    parsing the content of the directory after checking the
    configuration.
    
*** Emacs mode
    Provides functions to jump to the roadmap of which the current
    buffer depends and several additional function not in org-mode to
    deal with the roadmap itself.

    |-----------+------------------------------------------------------+-----------------------------|
    | shortcut  | description                                          | elisp function name         |
    |-----------+------------------------------------------------------+-----------------------------|
    | `C-d r`   | When the current buffer is a roadmap, updates it.    | roadmap-reload              |
    | `C-d h`   | Opens the roadmap ruling the current file  (if any). | roadmap-go-home             |
    | `C-d i t` | Inserts a TODO item.                                 | roadmap-insert-todo         |
    | `C-d i i` | Inserts an IDEA item.                                | roadmap-insert-idea         |
    | `C-d n`   | Goes to the next item in the same file               | roadmap-go-to-next-item     |
    | `C-d p`   | Goes to the previousitem in the same file            | roadmap-go-to-previous-item |
    |-----------+------------------------------------------------------+-----------------------------|

* Bash
  Here comes the serious stuff. The actual code used to perform the
  tasks mentionned above is written in a literate way using
  org-babel. To "untangle" the bash code from this file, run
  "org-babel-tangle-file" (or C-c C-v f). This will create roadmap.sh,
  a file which you simply need to load (. roadmap.sh) to have all the
  functions necessary.

  All the functions and constants use the "rod_" prefix to make sure
  they won't ever collide with any other command.
** Base
   !TODO! Add a list of files to accept (and turn the old regexp into a default setting).
   !IDEA! Integration with anordnakod: settings go in the roadmap.
   !IDEA! Expanding on the above: add functions to easily retrieve variable value from a roadmap.
*** shebang
    It all starts with a shebang, always. Thus, we add that
    corresponding to bash on any decent system at the beginning of the
    file. We also add an author comment.
    #+begin_src sh :shebang "#!/bin/bash" :tangle roadmap.sh
    # AUTHOR: Leo Perrin <leoperrin@picarresursix.fr>
    #+end_src
*** Loading configuration
    Assuming there is an empty roadmap.org file in the directory, we
    want to take into account the configuration stored in it before
    going any further. To do so, we grep the keywords on the file and
    assign the corresponding variables accordingly.

    #+begin_src sh :tangle roadmap.sh
      function rod_load_configuration
      {
          if [[ $# < 1 ]]
          then
              rod_file=roadmap.org
          else
              rod_file=$1
          fi
          if [[ ! -e $rod_file ]]
          then
              echo "No "$rod_file" file here! I can't update a none existing file."
              echo "usage: rod_update roadmap_file (roadmap_file is optionnal; defaults to \"roadmap.org\""
          else
              rod_ACCEPT_ONLY_FILES=$(grep "INCLUDE_ONLY:" $rod_file | cut -d ":" -f 2 | cut -c 2-)      
              rod_EXCLUDE_FILES=$(grep "EXCLUDE:" $rod_file | cut -d ":" -f 2 | cut -c 2-)
          fi
      }
    #+end_src
*** Listing interesting files
    First of all, we generate a list of all the files with their
    extension and path. This is the base from which we shall work
    later. The default setting is: "we are not interested in backup and
    hidden files so we remove those ending with "~" and those starting
    with either "." or "#"". However, this can be overridden.

    In order to accept only the files matching a pattern, we loop over
    the patterns in rod_ACCEPT_ONLY_FILES and use grep to remove the
    files not matching each of them.

    In order to remove files matching the patterns in
    rod_EXCLUDE_FILES, we loop over the patterns and use "grep -v" to
    remove the files matching each of them from the list.

    Note that in order to keep new-line separated lists, we modify the
    value of [[http://tldp.org/LDP/abs/html/internalvariables.html#IFS][IFS]] several times. In the for loop, we modify/set it back
    several times because the $rod_EXCLUDE_FILES is space separated
    while $rod_result is new_line separated.

    Note also that $pattern has to be enclosed between '"' in order
    for it to be interpreted as a regexp and not a simple string.
    #+begin_src sh :tangle roadmap.sh
      function rod_list_files
      {
          old_IFS=$IFS
          IFS=''
          rod_result=$(find . -name "[^.^\#]*.*[^~]")
          IFS=$old_IFS
          for pattern in $rod_ACCEPT_ONLY_FILES
          do
              IFS=''
              rod_result=$(grep "$pattern" <<< $rod_result)
              IFS=$old_IFS
          done
          for pattern in $rod_EXCLUDE_FILES
          do
              IFS=''
              rod_result=$(grep -v "$pattern" <<< $rod_result)
              IFS=$old_IFS
          done
          IFS=''
          echo $rod_result #${rod_result//$'\n'/\n/}
          IFS=$old_IFS
      }
      
    #+end_src
** Updating the filen
*** Extensions
    This program can sort files according to their extensions so we
    need to know which goes in which category.
**** rod_EXTENSIONS_HEADERS
     Extensions supposed to correspond to headers of any kind.
     #+begin_src sh :tangle roadmap.sh
          rod_EXTENSIONS_HEADERS="hpp h"
     #+end_src
**** rod_EXTENSIONS_CODE
     Extensions supposed to correspond to actual code.
     #+begin_src sh :tangle roadmap.sh
           rod_EXTENSIONS_CODE="c cpp py sage el html php css sh tex"
     #+end_src
*** Statistics
**** Counting
    First, we need to list the files we are interested in.  Once this
    is done, we count the number of files having each extension, sort
    them by type and display the result. To do so, we initialise a
    counter to zero for each of the quantities we are interested
    in. Then, we list the files and go through all of them,
    incrementing the counters accordingly. At last, we pretty print
    the data. Note that the header/code distinction is relevant if and
    only if there are headers (there is always code) so we display the
    code/header data only if the number of header files is non-zero.
    #+begin_src sh :tangle roadmap.sh
       function rod_display_file_stat
       {
           # initialising the counters for each extensions
           number_h=0    ; length_h=0
           number_hpp=0  ; length_hpp=0
           number_c=0    ; length_c=0
           number_cpp=0  ; length_cpp=0
           number_py=0   ; length_py=0
           number_sage=0 ; length_sage=0
           number_el=0   ; length_el=0
           number_html=0 ; length_html=0
           number_css=0  ; length_css=0
           number_php=0  ; length_php=0
           number_sh=0   ; length_sh=0
           number_tex=0  ; length_tex=0 
           number_txt=0  ; length_txt=0 
           number_org=0  ; length_org=0 
           number_md=0   ; length_md=0
           number_misc=0 ; length_misc=0
           total_files=0 ; length_total=0
       
           # listing the files
           list_files=$(rod_list_files $1)
       
           # going through the files and counting
           for file in $list_files; do
               extension=$(echo $file | cut -d "." -f 3)
               length=$(wc -l $file | cut -d " " -f 1)
               ((total_files = $total_files+1))
               ((length_total = $length_total+$length))
               case $extension in
                   h)  ((number_h = $number_h+1))
                       ((length_h = $length_h+$length)) ;;
                   hpp)  ((number_hpp = $number_hpp+1))
                       ((length_hpp = $length_hpp+$length)) ;;
                   c)  ((number_c = $number_c+1))
                       ((length_c = $length_c+$length)) ;;
                   cpp)  ((number_cpp = $number_cpp+1))
                       ((length_cpp = $length_cpp+$length)) ;;
                   py)  ((number_py = $number_py+1))
                       ((length_py = $length_py+$length)) ;;
                   sage)  ((number_sage = $number_sage+1))
                       ((length_sage = $length_sage+$length)) ;;
                   el)  ((number_el = $number_el+1))
                       ((length_el = $length_el+$length)) ;;
                   html)  ((number_html = $number_html+1))
                       ((length_html = $length_html+$length)) ;;
                   css)  ((number_css = $number_css+1))
                       ((length_css = $length_css+$length)) ;;
                   php)  ((number_php = $number_php+1))
                       ((length_php = $length_php+$length)) ;;
                   sh)  ((number_sh = $number_sh+1))
                       ((length_sh = $length_sh+$length)) ;;
                   tex)  ((number_tex = $number_tex+1))
                       ((length_tex = $length_tex+$length)) ;;
                   txt)  ((number_txt = $number_txt+1))
                       ((length_txt = $length_txt+$length)) ;;
                   org)  ((number_org = $number_org+1))
                       ((length_org = $length_org+$length)) ;;
                   md)  ((number_md = $number_md+1))
                       ((length_md = $length_md+$length)) ;;
                   *)  ((number_misc = $number_misc+1))
                       ((length_misc = $length_misc+$length)) ;;
               esac
               done
             
           # computing the numbers for each type
           ((number_header=$number_h+$number_hpp))
           ((length_header=$length_h+$length_hpp))
           ((number_code=$number_c+$number_cpp+$number_py+$number_sage+$number_el+$number_html+$number_css+$number_php+$number_el+$number_sh+$number_tex))
           ((length_code=$length_c+$length_cpp+$length_py+$length_sage+$length_el+$length_html+$length_css+$length_php+$length_el+$length_sh+$length_tex))
           ((number_documentation=$number_txt+$number_org+$number_md))
           ((length_documentation=$length_txt+$length_org+$length_md))
       
           # displaying the results
           echo -e "** global statistics: #files #lines"
           echo -e "   + total:     "$total_files"\t"$length_total
       
           if [[ $number_header != 0 ]]; then
               echo -e "   + headers:   "$number_header"\t"$length_header
           fi
           if [[ $number_code != 0 ]]; then
               echo -e "   + code:      "$number_code"\t"$length_code
           fi
           if [[ $number_documentation != 0 ]]; then
               echo -e "   + doc/notes: "$number_documentation"\t"$length_documentation
           fi
       
           echo -e "** Files sorted by extension"
           if [[ $number_h    != 0 ]]; then echo -e "   + h:   "$number_h"\t"$length_h ; fi
           if [[ $number_c    != 0 ]]; then echo -e "   + c:   "$number_c"\t"$length_c ; fi
           if [[ $number_hpp  != 0 ]]; then echo -e "   + hpp: "$number_hpp"\t"$length_hpp ; fi
           if [[ $number_cpp  != 0 ]]; then echo -e "   + cpp: "$number_cpp"\t"$length_cpp ; fi
           if [[ $number_py   != 0 ]]; then echo -e "   + py : "$number_py"\t"$length_py ; fi
           if [[ $number_sage != 0 ]]; then echo -e "   + sage:"$number_sage"\t"$length_sage ; fi
           if [[ $number_el   != 0 ]]; then echo -e "   + el:  "$number_el"\t"$length_el ; fi
           if [[ $number_html != 0 ]]; then echo -e "   + html:"$number_html"\t"$length_html ; fi
           if [[ $number_css  != 0 ]]; then echo -e "   + css: "$number_css"\t"$length_css ; fi
           if [[ $number_php  != 0 ]]; then echo -e "   + php: "$number_php"\t"$length_php ; fi
           if [[ $number_sh   != 0 ]]; then echo -e "   + sh:  "$number_sh"\t"$length_sh ; fi
           if [[ $number_tex  != 0 ]]; then echo -e "   + tex: "$number_tex"\t"$length_tex ; fi
           if [[ $number_txt  != 0 ]]; then echo -e "   + txt: "$number_txt"\t"$length_txt ; fi
           if [[ $number_org  != 0 ]]; then echo -e "   + org: "$number_org"\t"$length_org ; fi
           if [[ $number_md   != 0 ]]; then echo -e "   + md:  "$number_md"\t"$length_md ; fi
           if [[ $number_misc != 0 ]]; then echo -e "   + misc:"$number_misc"\t"$length_misc ; fi
       }
       
    #+end_src
    
*** Items
**** Listing the items
    First, we list the items.  To do so, recall that an item is added
    to any text file using ITEM_IDENTIFER\: at the beginning of a line
    (without the backslash of course). Thus, all we need to do is to
    "grep" them among all the interesting files given by 

    We are now ready to look at the items. The structure of the output
    of "grep -n pattern files" turns out to be great for us. Indeed, it
    consists in "path-to-file:line:actual line". Thus we just have to
    use the cut bash function to output nice links and descriptions.
    The following functions takes an item as its input and outputs an
    org-mode second-level entry containing a list with the description
    of the items as links to the file and link to them.

    Since the output of grep is '\n' separated, we modify temporarily
    the value of $IFS. If we don't do that, every word in each line is
    considered like a different item.
    #+begin_src sh :tangle roadmap.sh
      function rod_display_item
      {
          if [[ $# < 1 ]]; then
              echo "Argument missing: I need an item to search for!"
          else
              # generating the list of relevant data
              item_list=$(grep -n \!$1\! $(rod_list_files))
              old_IFS=$IFS
              IFS=$'\n'
      
              # displaying the links
              echo "\\*\\* [/] "${1^^}" list"
              index=0
              for item in $item_list; do
                 ((index=$index+1))
                 file=$(echo $item | cut -d ":" -f 1)
                 line_number=$(echo $item | cut -d ":" -f 2)
                 description=$(echo $item | cut -d "!" -f 3- | cut -c 2-)
                 echo "   "$index". [ ] [[file:"$(pwd)"/"$file"::"$line_number"]["$description"]] ("$file":"$line_number")"
              done
          fi
      
          IFS=$old_IFS
      }
      
    #+end_src

**** Removing heading
     First, we need to remove the previous version of some blocks. These
     are delimited on top by "\* Statistics" and "\* Items" and on the
     bottom by the next first level heading, so a line starting with "\*
     " followed by an upper cased letter an then some random things.
     
     Thus, all we need to do is to go through the file and toggle an
     "output" variable between 0 (in which we print the line) and 1 (in
     which case we don't print anything). Example:
     |--------+--------------|
     | output | line         |
     |--------+--------------|
     |      0 | ROADMAP      |
     |      0 |              |
     |      0 | * Statistics |
     |      1 | ** files     |
     |      1 | + blablabla  |
     |      1 | + bliblibli  |
     |      0 | * Items      |
     |      0 | + blublublu  |
     |      0 | ...          |
     |      0 | .            |
     |--------+--------------|
     
     To do so, we use awk.
     #+begin_src sh :tangle roadmap.sh
         function rod_remove_heading
         {
             if [[ $# < 2 ]]
             then
                 echo "I need to know wich heading to remove from which file, sorry."
                 echo "usage: rod_remove_heading <heading> <file>"
             else
                 awk 'BEGIN {c=0}                           \
                      {                                     \
                          if (/^\* '$1'/)                   \
                             {c=1; print $0}                \
                          else if ((c==1)&&(/^\* [A-Z].*/)) \
                             {c=0; print $0}                \
                          else if (c==0)                    \
                             {print $0}                     \
                      }' $2
              fi
         }
     #+end_src
     
**** Inserting new heading
     Now we need a function to insert the data newly generated into the
     roadmap. We do this using sed. In order to deal with the snippets
     of text being multi-lined, we use a substitution: we replace
     bash's new line "$'\n'" without "normal" new lines "\n".
     #+begin_src sh :tangle roadmap.sh
             function rod_update
             {
                 if [[ $# < 1 ]]
                 then
                     rod_file=roadmap.org
                 else
                     rod_file=$1
                 fi
                 if [[ ! -e $rod_file ]]
                 then
                     echo "No "$rod_file" file here! I can't update a none existing file."
                     echo "usage: rod_update roadmap_file (roadmap_file is optionnal; defaults to \"roadmap.org\""
                 else
                     # removing previous headings
                     rod_remove_heading Items $rod_file > $rod_file.temp
                     rod_remove_heading Statistics $rod_file.temp > $rod_file
                     rm $rod_file.temp
             
                     # adding new content
                     stat_file=$(rod_display_file_stat)
                     item_todo=$(rod_display_item TODO)
                     item_idea=$(rod_display_item IDEA)
                     sed -i "/^\* Statistics/a${stat_file//$'\n'/\n}" $rod_file
                     sed -i "/^\* Items/a${item_idea//$'\n'/\n}" $rod_file
                     sed -i "/^\* Items/a${item_todo//$'\n'/\n}" $rod_file
                     echo "Roadmap updated successfully!"
                 fi
             }
     #+end_src

** The main roadmap
   The "main roadmap" of a subtree of the directory is the roadmap
   describing all the files in the said subtree. We want to be able to
   know which is the main roadmap of any folder. To do so, we go up
   the directory tree and stop when a parent folder contains a
   roadmap.org file. We then return the full-path to this file.

   In order to make sure the function stops, we tell it to stop when
   the root is reached. Also, to come back where we were when we
   called the function, we pass the path to the first directory we
   were in as an argument and "cd" back to it when done.
   #+begin_src sh :tangle roadmap.sh
     function rod_main_roadmap
     {
         if [[ $# < 1 ]]
         then
             current_dir=$(pwd)
         else
             current_dir=$1
         fi
     
         if [[ $(pwd) == "/" ]]
         then
             echo ""
             cd $current_dir
         elif [[ -e roadmap.org ]]
         then
             echo $(pwd)/roadmap.org
             cd $current_dir
         else
             cd ..
             rod_main_roadmap $current_dir
         fi
     }
   #+end_src
** Displaying help
   When called with the "--help" argument or with no argument at all,
   we want the script to display a short help. This is extremely
   straightforward: we use "echo".

   #+begin_src sh :tangle roadmap.sh
     function rod_help
     {
        echo "Usage: roadmap -OPTION"
        echo ""
        echo "OPTION has to be one of the following:"
        echo "   -n: creates an empty roadmap.org file in the current directory."
        echo "   -u: updates the roadmap.org file in the current directory."
        echo "   -h: displays the path to the roadmap ruling this directory tree."
     }
   #+end_src
** Main function
   Now that we have all the components we need, it is time to write
   the main part of script. Recall that it has the following usage:
   + roadmap -n: creates an empty roadmap.org file in the current
     directory.
   + roadmap -u: updates the roadmap.org file in the current
     directory.
   + roadmap -h: displays the path to the roadmap ruling this
     directory tree.

   We parse the arguments using getopt. In order to print the help if
   no valid argument were given, we initialize a variable "happy"
   to 0. If a valid was found, happy is set to 1. If happy is still 0
   in the end or if a none-valid option was given, we display the help.

   #+begin_src sh :tangle roadmap.sh
     happy=0
     while getopts ":nuh" option
     do
         case $option in
             n)
                 cp ~/regulus/roadmap/roadmap-template.org ./roadmap.org
                 echo "new roadmap created"
                 happy=1
                 ;;
             u)
                 rod_load_configuration
                 echo "Configuration loaded"
                 rod_update
                 happy=1
                 ;;
             h)
                 rod_main_roadmap
                 happy=1
                 ;;
             \?)
                 echo "Invalid option: -$OPTARG"
                 rod_help
                 exit 1
         esac
     done
     
     if [[ $happy == 0 ]]
     then
         rod_help
     fi
   #+end_src

* Elisp
** Reloading the roadmap
*** roadmap-reload
    This function is very straightforward: we run the shell command
    "roadmap -u" and then use the "revert-buffer" elisp function to
    reload the buffer to take the changes into account.
    #+begin_src lisp :tangle roadmap.el
      (defun roadmap-reload()
        "Reload the current roadmap."
        (interactive)
        (shell-command "roadmap -u")
        (revert-buffer)
        )
    #+end_src
** The main roadmap
*** roadmap-find-main
    This function goes up in the directory tree until it finds a
    roadmap.org file in one of the parent directories. Then, it
    returns the path to the said file or an empty string if it didn't
    find any.

    We use the output of "roadmap -h" but, to retrieve it, we need to
    get the content of the "*Shell Command Output*" buffer (and remove
    the last character, a new line). Then, we move to back to the
    buffer we were and, to be able to do so, we first store the said
    buffer in a variable.
    #+begin_src lisp :tangle roadmap.el
      (defun roadmap-find-main()
        "Returns the path to roadmap of which the current file depends or an
      empty string if there is no such roadmap."
        (setq old-buffer (current-buffer))
        (shell-command "roadmap -h")
        (switch-to-buffer "*Shell Command Output*")
        (setq path-to-main-roadmap
              (buffer-substring-no-properties (point-min) (- (point-max) 1))
              )
        (switch-to-buffer old-buffer)
        path-to-main-roadmap
        )
    #+end_src
*** roadmap-open-main
    Opens the roadmap of which the current file depends using the
    output of roadmap-find-main. If there is no such buffer, does
    nothing.
    #+begin_src lisp :tangle roadmap.el
      (defun roadmap-open-main()
        "Open the roadmap of which the current file depends (if any)."
        (interactive)
        (setq path-to-main-roadmap (roadmap-find-main))
        (if (< 2 (length path-to-main-roadmap))
            (progn
              (find-file path-to-main-roadmap)
              (message (concat "Opening " path-to-main-roadmap))
              )
            (message "No roadmap found.")
            )
        )
    #+end_src
** Interacting with items in a file
   Items live in "regular" file, i.e. those I actually work with: .c,
   .cpp, .tex, .py, etc. Thus, I want to interact with items all the
   time: inserting them and locating them easily.
*** roadmap-insert-todo
    We want common items to be easy to insert, so we create a small
    function to quickly put them where the cursor is. Nothing fancy,
    it just an interactive call to "insert". We don't write the item
    within its exclamation marks so as not to confused the roadmap
    script (we of course use it to manage the implementation of
    itself).
    #+begin_src lisp :tangle roadmap.el
      (defun roadmap-insert-todo()
        "Inserts a TODO roadmap item."
        (interactive)
        (insert (concat "!" "TODO! "))
        )
    #+end_src
*** roadmap-insert-idea
    Exactly the same as above, but for the "IDEA" item.
    #+begin_src lisp :tangle roadmap.el
      (defun roadmap-insert-idea()
        "Inserts a TODO roadmap item."
        (interactive)
        (insert (concat "!" "IDEA! "))
        )
    #+end_src
*** roadmap-go-to-next-item
    If there is another item further in the file, moves the cursor to
    it.
    #+begin_src lisp :tangle roadmap.el
          (defun roadmap-go-to-next-item()
            (interactive)
            (search-forward-regexp "\![^ ]*\!")
            )
    #+end_src
*** roadmap-go-to-previous-item
    The same as before, but for what is before in the file.
    #+begin_src lisp :tangle roadmap.el
          (defun roadmap-go-to-previous-item()
            (interactive)
            (search-backward-regexp "\![^ ]*\!")
            )
    #+end_src
** roadmap-mode
*** minor-mode declaration
   We want to define a minor-mode granting access to the keybindings
   and the fontifying of known items. To do so, we apply what is
   suggested [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Minor-Modes.html#Defining-Minor-Modes][here]]. The keymap had to employ a backquote and commas,
   take a look at [[http://stackoverflow.com/questions/3115104/how-to-create-keybindings-for-a-custom-minor-mode-in-emacs][stackoverflow]] to see why.
   #+begin_src lisp :tangle roadmap.el
     (define-minor-mode roadmap-mode
         "Toggle roadmap mode.

       Interactively with no argument, this command toggles the mode.
       A positive prefix argument enables the mode, any other prefix
       argument disables it.  From Lisp, argument omitted or nil enables
       the mode, `toggle' toggles the state. "
        ;; The initial value.
        :init-value nil
        ;; The indicator for the mode line.
        :lighter " Rod"
        :keymap
        `(
          (,(kbd "C-d r")   . roadmap-reload)
          (,(kbd "C-d h")   . roadmap-open-main)
          (,(kbd "C-d i t") . roadmap-insert-todo)
          (,(kbd "C-d i i") . roadmap-insert-idea)
          (,(kbd "C-d n")   . roadmap-go-to-next-item)
          (,(kbd "C-d p")   . roadmap-go-to-previous-item)
          )
        )
   #+end_src

*** Fontifying
   Now that we have a minor-mode, we add fontifying for the
   items. Items are strings containing non-space character enclosed
   between exclamation marks, so we look for this pattern.
   #+begin_src lisp :tangle roadmap.el
     (add-hook 'roadmap-mode-hook
              (lambda ()
                (font-lock-add-keywords nil '(("!\\([^ ]*\\)!" 1 font-lock-warning-face t)))
                )
              )
   #+end_src

*** Adding a hook to turn on the mode
    We want the roadmap minor-mode to be switched on whenever a file
    is on the directory tree below a roadmap. To do so, we check that
    the output of roadmap-find-main has a greater than 1 length.
    #+begin_src lisp :tangle roadmap.el
      (add-hook 'find-file-hook
                (lambda()
                  (if (< 1 (length (roadmap-find-main)))
                      (roadmap-mode)
                    )
                  )
                )
    #+end_src
