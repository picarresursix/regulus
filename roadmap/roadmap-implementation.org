#+ -*-org-*-; Time-stamp: <2012-12-29 02:07:40 leo>

                  ROADMAP



* Introduction
  When programming or writing LaTeX report (or anything else involving
  editing text files), I use a "roadmap", a file containing useful
  information about what's left to do, ideas, etc.

  Believe it or not, it relies on org-mode. The functions here allow
  to update this file automatically from small tags written directly
  in the code I am writing (no need to move back to the roadmap and
  then back again to what I'm working on).

  The basic concept is that of _item_. An item is just a case
  sensitive word followed by "::" somewhere in a file. Thus, it should
  be particular (ex: 'the' is a bad item while 'TODO' is a good
  one). Current items are:
    - TODO These correspond to tasks left to be done.
    - IDEA Possible improvement or directions to explore.

  Functions to make it easy to use this roadmap with emacs are
  provided. They allow to:
    + IDEA: Add links to compile the project
    + IDEA: Add a link to open a shell (within emacs) at the current
      location.
    + IDEA: Add a list of all the commits' short description.
      For instance, we could use "grep -v "[^ ]:" <(git log)" or
      something.

  The roadmap script is used as follows:
    + roadmap -n
      Creates a new roadmap at the given point.
    + roadmap -u
      Updates the roadmap in the current directory.
    + roadmap -h
      Prints the path to the roadmap of which the current file depends
      on.
* Description
** Description of the roadmap itself
   A roadmap is made of the following parts.
*** Statistics
    + The number of files in the directory (sorted by extension) and
      their length (and total length).
    + The number of the different items.
    + Date of last modification of the roadmap.
    + Date of the last commit and description (if any).
*** Lists
    Lists of the different items considered. Each line is as follows:

    "** ITEM description"

    where "description" is a link to the file and line where the item
    was as well as the string following the item in the file.

    Currently supported lists are:
    + TODO list
    + IDEA list

      These part should not be modified by hand: it is this programs
      task to generate them. Any modification is thus overriden during
      the next update.
*** Structure
    TODO: implement the treeview structure of the folder.
    A simple treeview of the folder structure of the directory where
    each node is a link to what it corresponds to. If two files have
    identical names (ex: class.hpp, class.cpp or report.tex and
    report.pdf) then a unique link will open both at the same time.

** Description of the programs used
   From a technical point of view, the Implementation has several
   different aspects. Indeed, while bash functions are used to create
   the file, emacs'org-mode is used to read it and roadmap-mode is
   used to interact with it from other buffers.
   
*** Bash functions
    The aim of the bash functions is to create the file itself by
    parsing the content of the directory after checking the
    configuration.
    
*** Emacs mode
    Provides functions to jump to the roadmap of which the current
    buffer depends and several additional function not in org-mode to
    deal with the roadmap itself.
    + (C-d r) (roadmap-reload) checks that the current file is a
      roadmap.org and, if so, updates the file and reverts the
      buffer. tl;dr: updates the roadmap.
    + (C-d h) (roadmap-go-home) go to the first roadmap encountered in
      a parent directory.
* Bash
  Here comes the serious stuff. The actual code used to perform the
  tasks mentionned above is written in a literate way using
  org-babel. To "untangle" the bash code from this file, run
  "org-babel-tangle-file" (or C-c C-v f). This will create roadmap.sh,
  a file which you simply need to load (. roadmap.sh) to have all the
  functions necessary.

  All the functions and constants use the "rom_" prefix to make sure
  they won't ever collide with any other command.
** Base
*** shebang
    It all starts with a shebang, always. Thus, we add that
    corresponding to bash on any decent system at the beginning of the
    file. We also add an author comment.
    #+begin_src sh :shebang "#!/bin/bash" :tangle roadmap.sh
    # AUTHOR: Leo Perrin <leoperrin@picarresursix.fr>
    #+end_src
*** Loading configuration
    Assuming there is an empty roadmap.org file in the directory, we
    want to take into account the configuration stored in it before
    going any further. To do so, we grep the keywords on the file and
    assign the corresponding variables accordingly.

    Since the variables are meant to be global, we initialise them to
    void *before* the declaration of the function.
    #+begin_src sh :tangle roadmap.sh
      function rod_load_configuration
      {
          if [[ $# < 1 ]]
          then
              rod_file=roadmap.org
          else
              rod_file=$1
          fi
          if [[ ! -e $rod_file ]]
          then
              echo "No "$rod_file" file here! I can't update a none existing file."
              echo "usage: rod_update roadmap_file (roadmap_file is optionnal; defaults to \"roadmap.org\""
          else
              rod_EXCLUDE_FILES=$(grep "EXCLUDE:" $rod_file | cut -d ":" -f 2 | cut -c 2-)
          fi
      }
    #+end_src
** Updating the file
*** Extensions
    This program can sort files according to their extensions so we
    need to know which goes in which category.
**** rod_EXTENSIONS_HEADERS
     Extensions supposed to correspond to headers of any kind.
     #+begin_src sh :tangle roadmap.sh
          rod_EXTENSIONS_HEADERS="hpp h"
     #+end_src
**** rod_EXTENSIONS_CODE
     Extensions supposed to correspond to actual code.
     #+begin_src sh :tangle roadmap.sh
           rod_EXTENSIONS_CODE="c cpp py sage el html php css sh tex"
     #+end_src
*** Statistics
**** Listing interesting files
    First of all, we generate a list of all the files with their
    extension and path. This is the base from which we shall work
    later. We are not interested in backup and hidden files so we
    remove those ending with "~" and those starting with either "." or
    "#".

    In order to remove files matching the patterns in
    rod_EXCLUDE_FILES, we loop over the patterns and use "grep -v" to
    remove the files matching each of them from the list.

    Note that in order to keep new-line separated lists, we modify the
    value of [[http://tldp.org/LDP/abs/html/internalvariables.html#IFS][IFS]] several times. In the for loop, we modify/set it back
    several times because the $rod_EXCLUDE_FILES is space separated
    while $rod_result is new_line separated.
    #+begin_src sh :tangle roadmap.sh
      function rod_list_files
      {
          old_IFS=$IFS
          IFS=''
          rod_result=$(find . -name "[^.^\#]*.*[^~]")
          IFS=$old_IFS
          for pattern in $rod_EXCLUDE_FILES
          do
              IFS=''
              rod_result=$(grep -v $pattern <<< $rod_result)
              IFS=$old_IFS
          done
          IFS=''
          echo $rod_result #${rod_result//$'\n'/\n/}
          IFS=$old_IFS
      }
    #+end_src

**** Counting
    First, we need to list the files we are interested in.  Once this
    is done, we count the number of files having each extension, sort
    them by type and display the result. To do so, we initialise a
    counter to zero for each of the quantities we are interested
    in. Then, we list the files and go through all of them,
    incrementing the counters accordingly. At last, we pretty print
    the data. Note that the header/code distinction is relevant if and
    only if there are headers (there is always code) so we display the
    code/header data only if the number of header files is non-zero.
    #+begin_src sh :tangle roadmap.sh
       function rod_display_file_stat
       {
           # initialising the counters for each extensions
           number_h=0    ; length_h=0
           number_hpp=0  ; length_hpp=0
           number_c=0    ; length_c=0
           number_cpp=0  ; length_cpp=0
           number_py=0   ; length_py=0
           number_sage=0 ; length_sage=0
           number_el=0   ; length_el=0
           number_html=0 ; length_html=0
           number_css=0  ; length_css=0
           number_php=0  ; length_php=0
           number_sh=0   ; length_sh=0
           number_tex=0  ; length_tex=0 
           number_txt=0  ; length_txt=0 
           number_org=0  ; length_org=0 
           number_md=0   ; length_md=0
           number_misc=0 ; length_misc=0
           total_files=0 ; length_total=0
       
           # listing the files
           list_files=$(rod_list_files $1)
       
           # going through the files and counting
           for file in $list_files; do
               extension=$(echo $file | cut -d "." -f 3)
               length=$(wc -l $file | cut -d " " -f 1)
               ((total_files = $total_files+1))
               ((length_total = $length_total+$length))
               case $extension in
                   h)  ((number_h = $number_h+1))
                       ((length_h = $length_h+$length)) ;;
                   hpp)  ((number_hpp = $number_hpp+1))
                       ((length_hpp = $length_hpp+$length)) ;;
                   c)  ((number_c = $number_c+1))
                       ((length_c = $length_c+$length)) ;;
                   cpp)  ((number_cpp = $number_cpp+1))
                       ((length_cpp = $length_cpp+$length)) ;;
                   py)  ((number_py = $number_py+1))
                       ((length_py = $length_py+$length)) ;;
                   sage)  ((number_sage = $number_sage+1))
                       ((length_sage = $length_sage+$length)) ;;
                   el)  ((number_el = $number_el+1))
                       ((length_el = $length_el+$length)) ;;
                   html)  ((number_html = $number_html+1))
                       ((length_html = $length_html+$length)) ;;
                   css)  ((number_css = $number_css+1))
                       ((length_css = $length_css+$length)) ;;
                   php)  ((number_php = $number_php+1))
                       ((length_php = $length_php+$length)) ;;
                   sh)  ((number_sh = $number_sh+1))
                       ((length_sh = $length_sh+$length)) ;;
                   tex)  ((number_tex = $number_tex+1))
                       ((length_tex = $length_tex+$length)) ;;
                   txt)  ((number_txt = $number_txt+1))
                       ((length_txt = $length_txt+$length)) ;;
                   org)  ((number_org = $number_org+1))
                       ((length_org = $length_org+$length)) ;;
                   md)  ((number_md = $number_md+1))
                       ((length_md = $length_md+$length)) ;;
                   *)  ((number_misc = $number_misc+1))
                       ((length_misc = $length_misc+$length)) ;;
               esac
               done
             
           # computing the numbers for each type
           ((number_header=$number_h+$number_hpp))
           ((length_header=$length_h+$length_hpp))
           ((number_code=$number_c+$number_cpp+$number_py+$number_sage+$number_el+$number_html+$number_css+$number_php+$number_el+$number_sh+$number_tex))
           ((length_code=$length_c+$length_cpp+$length_py+$length_sage+$length_el+$length_html+$length_css+$length_php+$length_el+$length_sh+$length_tex))
           ((number_documentation=$number_txt+$number_org+$number_md))
           ((length_documentation=$length_txt+$length_org+$length_md))
       
           # displaying the results
           echo -e "** global statistics: #files #lines"
           echo -e "   + total:     "$total_files"\t"$length_total
       
           if [[ $number_header != 0 ]]; then
               echo -e "   + headers:   "$number_header"\t"$length_header
           fi
           if [[ $number_code != 0 ]]; then
               echo -e "   + code:      "$number_code"\t"$length_code
           fi
           if [[ $number_documentation != 0 ]]; then
               echo -e "   + doc/notes: "$number_documentation"\t"$length_documentation
           fi
       
           echo -e "** Files sorted by extension"
           if [[ $number_h    != 0 ]]; then echo -e "   + h:   "$number_h"\t"$length_h ; fi
           if [[ $number_c    != 0 ]]; then echo -e "   + c:   "$number_c"\t"$length_c ; fi
           if [[ $number_hpp  != 0 ]]; then echo -e "   + hpp: "$number_hpp"\t"$length_hpp ; fi
           if [[ $number_cpp  != 0 ]]; then echo -e "   + cpp: "$number_cpp"\t"$length_cpp ; fi
           if [[ $number_py   != 0 ]]; then echo -e "   + py : "$number_py"\t"$length_py ; fi
           if [[ $number_sage != 0 ]]; then echo -e "   + sage:"$number_sage"\t"$length_sage ; fi
           if [[ $number_el   != 0 ]]; then echo -e "   + el:  "$number_el"\t"$length_el ; fi
           if [[ $number_html != 0 ]]; then echo -e "   + html:"$number_html"\t"$length_html ; fi
           if [[ $number_css  != 0 ]]; then echo -e "   + css: "$number_css"\t"$length_css ; fi
           if [[ $number_php  != 0 ]]; then echo -e "   + php: "$number_php"\t"$length_php ; fi
           if [[ $number_sh   != 0 ]]; then echo -e "   + sh:  "$number_sh"\t"$length_sh ; fi
           if [[ $number_tex  != 0 ]]; then echo -e "   + tex: "$number_tex"\t"$length_tex ; fi
           if [[ $number_txt  != 0 ]]; then echo -e "   + txt: "$number_txt"\t"$length_txt ; fi
           if [[ $number_org  != 0 ]]; then echo -e "   + org: "$number_org"\t"$length_org ; fi
           if [[ $number_md   != 0 ]]; then echo -e "   + md:  "$number_md"\t"$length_md ; fi
           if [[ $number_misc != 0 ]]; then echo -e "   + misc:"$number_misc"\t"$length_misc ; fi
       }
       
    #+end_src
    
*** Items
**** Listing the items
    First, we list the items.  To do so, recall that an item is added
    to any text file using ITEM_IDENTIFER\: at the beginning of a line
    (without the backslash of course). Thus, all we need to do is to
    "grep" them among all the interesting files given by 

    We are now ready to look at the items. The structure of the output
    of "grep -n pattern files" turns out to be great for us. Indeed, it
    consists in "path-to-file:line:actual line". Thus we just have to
    use the cut bash function to output nice links and descriptions.
    The following functions takes an item as its input and outputs an
    org-mode second-level entry containing a list with the description
    of the items as links to the file and link to them.

    Since the output of grep is '\n' separated, we modify temporarily
    the value of $IFS. If we don't do that, every word in each line is
    considered like a different item.
    #+begin_src sh :tangle roadmap.sh
      function rod_display_item
      {
          if [[ $# < 1 ]]; then
              echo "Argument missing: I need an item to search for!"
          else
              # generating the list of relevant data
              item_list=$(grep -n $1: $(rod_list_files))
              old_IFS=$IFS
              IFS=$'\n'
      
              # displaying the links
              echo "\\*\\* [/] "${1^^}" list"
              index=0
              for item in $item_list; do
                 ((index=$index+1))
                 file=$(echo $item | cut -d ":" -f 1)
                 line_number=$(echo $item | cut -d ":" -f 2)
                 description=$(echo $item | cut -d ":" -f 4 | cut -c 2-)
                 echo "   "$index". [ ] [[file:"$(pwd)"/"$file"::"$line_number"]["$description"]] ("$file":"$line_number")"
              done
          fi
      
          IFS=$old_IFS
      }
      
    #+end_src

**** Removing heading
     First, we need to remove the previous version of some blocks. These
     are delimited on top by "\* Statistics" and "\* Items" and on the
     bottom by the next first level heading, so a line starting with "\*
     " followed by an upper cased letter an then some random things.
     
     Thus, all we need to do is to go through the file and toggle an
     "output" variable between 0 (in which we print the line) and 1 (in
     which case we don't print anything). Example:
     |--------+--------------|
     | output | line         |
     |--------+--------------|
     |      0 | ROADMAP      |
     |      0 |              |
     |      0 | * Statistics |
     |      1 | ** files     |
     |      1 | + blablabla  |
     |      1 | + bliblibli  |
     |      0 | * Items      |
     |      0 | + blublublu  |
     |      0 | ...          |
     |      0 | .            |
     |--------+--------------|
     
     To do so, we use awk.
     #+begin_src sh :tangle roadmap.sh
         function rod_remove_heading
         {
             if [[ $# < 2 ]]
             then
                 echo "I need to know wich heading to remove from which file, sorry."
                 echo "usage: rod_remove_heading <heading> <file>"
             else
                 awk 'BEGIN {c=0}                           \
                      {                                     \
                          if (/^\* '$1'/)                   \
                             {c=1; print $0}                \
                          else if ((c==1)&&(/^\* [A-Z].*/)) \
                             {c=0; print $0}                \
                          else if (c==0)                    \
                             {print $0}                     \
                      }' $2
              fi
         }
     #+end_src
     
**** Inserting new heading
     Now we need a function to insert the data newly generated into the
     roadmap. We do this using sed. In order to deal with the snippets
     of text being multi-lined, we use a substitution: we replace
     bash's new line "$'\n'" without "normal" new lines "\n".
     #+begin_src sh :tangle roadmap.sh
             function rod_update
             {
                 if [[ $# < 1 ]]
                 then
                     rod_file=roadmap.org
                 else
                     rod_file=$1
                 fi
                 if [[ ! -e $rod_file ]]
                 then
                     echo "No "$rod_file" file here! I can't update a none existing file."
                     echo "usage: rod_update roadmap_file (roadmap_file is optionnal; defaults to \"roadmap.org\""
                 else
                     # removing previous headings
                     rod_remove_heading Items $rod_file > $rod_file.temp
                     rod_remove_heading Statistics $rod_file.temp > $rod_file
                     rm $rod_file.temp
             
                     # adding new content
                     stat_file=$(rod_display_file_stat)
                     item_todo=$(rod_display_item TODO)
                     item_idea=$(rod_display_item IDEA)
                     sed -i "/^\* Statistics/a${stat_file//$'\n'/\n}" $rod_file
                     sed -i "/^\* Items/a${item_idea//$'\n'/\n}" $rod_file
                     sed -i "/^\* Items/a${item_todo//$'\n'/\n}" $rod_file
                     echo "Roadmap updated successfully!"
                 fi
             }
     #+end_src

** The main roadmap
   The "main roadmap" of a subtree of the directory is the roadmap
   describing all the files in the said subtree. We want to be able to
   know which is the main roadmap of any folder. To do so, we go up
   the directory tree and stop when a parent folder contains a
   roadmap.org file. We then return the full-path to this file.

   In order to make sure the function stops, we tell it to stop when
   the root is reached. Also, to come back where we were when we
   called the function, we pass the path to the first directory we
   were in as an argument and "cd" back to it when done.
   #+begin_src sh :tangle roadmap.sh
     function rod_main_roadmap
     {
         if [[ $# < 1 ]]
         then
             current_dir=$(pwd)
         else
             current_dir=$1
         fi
     
         if [[ $(pwd) == "/" ]]
         then
             echo ""
             cd $current_dir
         elif [[ -e roadmap.org ]]
         then
             echo $(pwd)/roadmap.org
             cd $current_dir
         else
             cd ..
             rod_main_roadmap $current_dir
         fi
     }
   #+end_src
** Main function
   Now that we have all the components we need, it is time to write
   the main part of script. Recall that it has the following usage:
   + roadmap -n: creates an empty roadmap.org file in the current
     directory.
   + roadmap -u: updates the roadmap.org file in the current
     directory.

   We parse the arguments using getopt.
   #+begin_src sh :tangle roadmap.sh
     while getopts ":nuh" option
     do
         case $option in
             n)
                 cp ~/regulus/roadmap/roadmap-template.org ./roadmap.org
                 echo "new roadmap created"
                 ;;
             u)
                 rod_load_configuration
                 echo "Configuration loaded"
                 rod_update
                 ;;
             h)
                 rod_main_roadmap
                 ;;
             \?)
                 echo "Invalid option: -$OPTARG"
                 exit 1
         esac
     done
   #+end_src

* Elisp
** Utils
*** roadmap-reload
    This function is very straightforward: we run the shell command
    "roadmap -u" and then use the "revert-buffer" elisp function to
    reload the buffer to take the changes into account.
    #+begin_src lisp :tangle roadmap.el
          (defun roadmap-reload()
            (interactive)
            (shell-command "roadmap -u")
            (revert-buffer)
            )
    #+end_src
*** roadmap-go-home
    This function first goes up in the directory tree until it finds a
    roadmap.org file in one of the parent directories. Then, it opens
    the said file in a buffer.
    #+begin_src lisp :tangle roadmap.el
            (defun roadmap-go-home()
              (interactive)
              (setq old-buffer (current-buffer))
              (shell-command "roadmap -h")
              (switch-to-buffer "*Shell Command Output*")
              (setq cont (buffer-substring-no-properties (point-min) (- (point-max) 1)))
              (message (number-to-string (length cont)))
              (if (< 2 (length cont))
                  (progn
                    (find-file cont)
                    (message (concat "Opening " cont))
                    )
                (progn
                  (message "No roadmap found.")
                  (switch-to-buffer old-buffer)
                  )
                )
              )
    #+end_src
** roadmap-mode
   We want to define a minor-mode granting access to the keybindings
   and the fontifying of known items. To do so, we apply what is
   suggested [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Minor-Modes.html#Defining-Minor-Modes][here]]. The keymap had to employ a backquote and commas,
   take a look at [[http://stackoverflow.com/questions/3115104/how-to-create-keybindings-for-a-custom-minor-mode-in-emacs][stackoverflow]] to see why.
   #+begin_src lisp :tangle roadmap.el
     (define-minor-mode roadmap-mode
         "Toggle roadmap mode.
       Interactively with no argument, this command toggles the mode.
       A positive prefix argument enables the mode, any other prefix
       argument disables it.  From Lisp, argument omitted or nil enables
       the mode, `toggle' toggles the state. "
        ;; The initial value.
        :init-value nil
        ;; The indicator for the mode line.
        :lighter " Rod"
        :keymap
        `(
          (,(kbd "C-d r") . roadmap-reload)
          (,(kbd "C-d h") . roadmap-go-home)
          )
        )
   #+end_src

   TODO: Create a hook which checks the value of roadmap-go-home when opening a file and activates (or not) roadmap-mode.
   TODO: switch to ;ITEM;
   #+end_src
   TODO: add fontifying of known items.
   IDEA: keep a list of the current items.
