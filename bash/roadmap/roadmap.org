#+ -*-org-*-; Time-stamp: <2012-12-22 23:57:27 leo>

                  ROADMAP



* Introduction
  When programming or writing LaTeX report (or anything else involving
  editing text files), I use a "roadmap", a file containing useful
  information about what's left to do, ideas, etc.

  Believe it or not, it relies on org-mode. The functions here allow
  to update this file automatically from small tags written directly
  in the code I am writing (no need to move back to the roadmap and
  then back again to what I'm working on).

  The basic concept is that of _item_. An item is just a case
  sensitive word followed by "::" somewhere in a file. Thus, it should
  be particular (ex: 'the' is a bad item while 'TODO' is a good
  one). Current items are:
    - TODO These correspond to tasks left to be done.
    - IDEA Possible improvement or directions to explore.

* Description
  A roadmap is made of the following parts.
** Statistics
   + The number of files in the directory (sorted by extension) and
     their length (and total length).
   + The number of the different items.
   + Date of last modification of the roadmap.
   + Date of the last commit and description (if any).
** Lists
   Lists of the different items considered. Each line is as follows:

   "** ITEM description"

   where "description" is a link to the file and line where the item
   was as well as the string following the item in the file.

   Currently supported lists are:
   + TODO list
   + IDEA list

     These part should not be modified by hand: it is this programs
     task to generate them. Any modification is thus overriden during
     the next update.
** Structure
   A simple treeview of the folder structure of the directory where
   each node is a link to what it corresponds to. If two files have
   identical names (ex: class.hpp, class.cpp or report.tex and
   report.pdf) then a unique link will open both at the same time.

* Implementation
  Here comes the serious stuff. The actual code used to perform the
  tasks mentionned above is written in a literate way using
  org-babel. To "untangle" the bash code from this file, run
  "org-babel-tangle-file" (or C-c C-v f). This will create roadmap.sh,
  a file which you simply need to load (. roadmap.sh) to have all the
  functions necessary.

  All the functions and constants use the "rom_" prefix to make sure
  they won't ever collide with any other command.
** Extensions
   This program can sort files according to their extensions so we
   need to know which goes in which category.
*** rod_EXTENSIONS_HEADERS
    Extensions supposed to correspond to headers of any kind.
    #+begin_src sh :tangle roadmap.sh
         rod_EXTENSIONS_HEADERS="hpp h"
    #+end_src
*** rod_EXTENSIONS_CODE
    Extensions supposed to correspond to actual code.
    #+begin_src sh :tangle roadmap.sh
          rod_EXTENSIONS_CODE="c cpp py sage el html php css sh tex"
    #+end_src
** Items
   Even though we will display the statistics first, we need first to
   look at the items. Indeed, since some statistics are about them, we
   need functions to deal with them *now*. The approach is very
   straight forward: first, we list the items.

   To do so, recall that an item is added to any text file using
   ITEM_IDENTIFER\: at the beginning of a line (without the backslash
   of course). Thus, all we need to do is to "grep" them among all the
   files.

   First of all, we generate a list of all the files with their
   extension and path. This is the base from which we shall work
   later.
   #+begin_src sh :tangle roadmap.sh
         function rod_list_files
         {
             find . -name "[^.^\#]*.*[^~]" -print
         }
   #+end_src

   Then, we shall build the org-mode links to the different items but
   first, we want a way to store their number (since we shall use it
   later). We simply introduce one globale variable per item type.
   #+begin_src sh :tangle roadmap.sh
        rod_ITEM_NUMBER_TODO=0
        rod_ITEM_NUMBER_IDEA=0
   #+end_src

   We are now ready to look at the items. The structure of the output
   of "grep -n pattern files" turns out to be great for us. Indeed, it
   consists in "path-to-file:line:actual line". Thus we just have to
   use the cut bash function to output nice links and descriptions.
   The following functions takes an item as its input and outputs an
   org-mode second-level entry containing a list with the description
   of the items as links to the file and link to them.

   Since the output of grep is '\n' separated, we modify temporarily
   the value of $IFS. If we don't do that, every word in each line is
   considered like a different item.
   #+begin_src sh :tangle roadmap.sh
     function rod_display_item
     {
         if [[ $# < 1 ]]; then
             echo "Argument missing: I need an item to search for!"
         else
             # initialising the correct counter to zero
             case $1 in
                 TODO) rod_ITEM_NUMBER_TODO=0 ;;
                 IDEA) rod_ITEM_NUMBER_IDEA=0 ;;
             esac
     
             # generating the list of relevant data
             item_list=$(grep -n $1: $(rod_list_files))
             old_IFS=$IFS
             IFS=$'\n'
     
             # displaying the links
             echo "** "${1^^}" list"
             for item in $item_list; do
                file=$(echo $item | cut -d ":" -f 1)
                line_number=$(echo $item | cut -d ":" -f 2)
                description=$(echo $item | cut -d ":" -f 4)
                echo "   + [[file:"$(pwd)"/"$file"::"$line_number"]["$description"]] ("$file":"$line_number")"
     
                # updating the correct counter
                case $1 in
                    TODO) ((rod_ITEM_NUMBER_TODO = rod_ITEM_NUMBER_TODO+1)) ;;
                    IDEA) ((rod_ITEM_NUMBER_IDEA = rod_ITEM_NUMBER_IDEA+1)) ;;
                esac
             done
         fi
         IFS=$old_IFS
     }
   #+end_src

** Statistics
*** Files statistics
    First, we need to list the files we are interested in.  Once this
    is done, we count the number of files having each extension, sort
    them by type and display the result. To do so, we initialise a
    counter to zero for each of the quantities we are interested
    in. Then, we list the files and go through all of them,
    incrementing the counters accordingly. At last, we pretty print
    the data. Note that the header/code distinction is relevant if and
    only if there are headers (there is always code) so we display the
    code/header data only if the number of header files is non-zero.
    #+begin_src sh :tangle roadmap.sh
      function rod_display_file_stat
      {
          # initialising the counters for each extensions
          number_h=0    ; length_h=0
          number_hpp=0  ; length_hpp=0
          number_c=0    ; length_c=0
          number_cpp=0  ; length_cpp=0
          number_py=0   ; length_py=0
          number_sage=0 ; length_sage=0
          number_el=0   ; length_el=0
          number_html=0 ; length_html=0
          number_css=0  ; length_css=0
          number_php=0  ; length_php=0
          number_sh=0   ; length_sh=0
          number_tex=0  ; length_tex=0 
          number_txt=0  ; length_txt=0 
          number_org=0  ; length_org=0 
          number_md=0   ; length_md=0
          number_misc=0 ; length_misc=0
          total_files=0 ; length_total=0
      
          # listing the files
          list_files=$(rod_list_files $1)
      
          # going through the files and counting
          for file in $list_files; do
              extension=$(echo $file | cut -d "." -f 3)
              length=$(wc -l $file | cut -d " " -f 1)
              ((total_files = $total_files+1))
              ((length_total = $length_total+$length))
              case $extension in
                  h)  ((number_h = $number_h+1))
                      ((length_h = $length_h+$length)) ;;
                  hpp)  ((number_hpp = $number_hpp+1))
                      ((length_hpp = $length_hpp+$length)) ;;
                  c)  ((number_c = $number_c+1))
                      ((length_c = $length_c+$length)) ;;
                  cpp)  ((number_cpp = $number_cpp+1))
                      ((length_cpp = $length_cpp+$length)) ;;
                  py)  ((number_py = $number_py+1))
                      ((length_py = $length_py+$length)) ;;
                  sage)  ((number_sage = $number_sage+1))
                      ((length_sage = $length_sage+$length)) ;;
                  el)  ((number_el = $number_el+1))
                      ((length_el = $length_el+$length)) ;;
                  html)  ((number_html = $number_html+1))
                      ((length_html = $length_html+$length)) ;;
                  css)  ((number_css = $number_css+1))
                      ((length_css = $length_css+$length)) ;;
                  php)  ((number_php = $number_php+1))
                      ((length_php = $length_php+$length)) ;;
                  sh)  ((number_sh = $number_sh+1))
                      ((length_sh = $length_sh+$length)) ;;
                  tex)  ((number_tex = $number_tex+1))
                      ((length_tex = $length_tex+$length)) ;;
                  txt)  ((number_txt = $number_txt+1))
                      ((length_txt = $length_txt+$length)) ;;
                  org)  ((number_org = $number_org+1))
                      ((length_org = $length_org+$length)) ;;
                  md)  ((number_md = $number_md+1))
                      ((length_md = $length_md+$length)) ;;
                  *)  ((number_misc = $number_misc+1))
                      ((length_misc = $length_misc+$length)) ;;
              esac
              done
            
          # computing the numbers for each type
          ((number_header=$number_h+$number_hpp))
          ((length_header=$length_h+$length_hpp))
          ((number_code=$number_c+$number_cpp+$number_py+$number_sage+$number_el+$number_html+$number_css+$number_php+$number_el+$number_sh+$number_tex))
          ((length_code=$length_c+$length_cpp+$length_py+$length_sage+$length_el+$length_html+$length_css+$length_php+$length_el+$length_sh+$length_tex))
          ((number_documentation=$number_txt+$number_org+$number_md))
          ((length_documentation=$length_txt+$length_org+$length_md))
      
          # displaying the results
          echo -e "** global statistics: #files #lines"
          echo -e "   + total:     "$total_files"\t"$length_total
      
          if [[ $number_header != 0 ]]; then
              echo -e "   + headers:   "$number_header"\t"$length_header
          fi
          if [[ $number_code != 0 ]]; then
              echo -e "   + code:      "$number_code"\t"$length_code
          fi
          if [[ $number_documentation != 0 ]]; then
              echo -e "   + doc/notes: "$number_documentation"\t"$length_documentation
          fi
      
          echo -e "** Files sorted by extension"
          if [[ $number_h    != 0 ]]; then echo -e "  + h:   "$number_h"\t"$length_h ; fi
          if [[ $number_c    != 0 ]]; then echo -e "  + c:   "$number_c"\t"$length_c ; fi
          if [[ $number_hpp  != 0 ]]; then echo -e "  + hpp: "$number_hpp"\t"$length_hpp ; fi
          if [[ $number_cpp  != 0 ]]; then echo -e "  + cpp: "$number_cpp"\t"$length_cpp ; fi
          if [[ $number_py   != 0 ]]; then echo -e "  + py : "$number_py"\t"$length_py ; fi
          if [[ $number_sage != 0 ]]; then echo -e "  + sage:"$number_sage"\t"$length_sage ; fi
          if [[ $number_el   != 0 ]]; then echo -e "  + el:  "$number_el"\t"$length_el ; fi
          if [[ $number_html != 0 ]]; then echo -e "  + html:"$number_html"\t"$length_html ; fi
          if [[ $number_css  != 0 ]]; then echo -e "  + css: "$number_css"\t"$length_css ; fi
          if [[ $number_php  != 0 ]]; then echo -e "  + php: "$number_php"\t"$length_php ; fi
          if [[ $number_sh   != 0 ]]; then echo -e "  + sh:  "$number_sh"\t"$length_sh ; fi
          if [[ $number_tex  != 0 ]]; then echo -e "  + tex: "$number_tex"\t"$length_tex ; fi
          if [[ $number_txt  != 0 ]]; then echo -e "  + txt: "$number_txt"\t"$length_txt ; fi
          if [[ $number_org  != 0 ]]; then echo -e "  + org: "$number_org"\t"$length_org ; fi
          if [[ $number_md   != 0 ]]; then echo -e "  + md:  "$number_md"\t"$length_md ; fi
          if [[ $number_misc != 0 ]]; then echo -e "  + misc:"$number_misc"\t"$length_misc ; fi
      }
      
    #+end_src
    
*** Items statistics
    The values we want to display are already known: all we have to do
    is to display them nicely.
    #+begin_src sh :tangle roadmap.sh
          function rod_display_stat_items
          {
              echo "** Items"
              echo "   + TODO items: "$rod_ITEM_NUMBER_TODO
              echo "   + IDEA items: "$rod_ITEM_NUMBER_IDEA
          }
    #+end_src


** Wrapping up
   TODO
